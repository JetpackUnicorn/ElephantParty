#include <unistd.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <netdb.h>#include <stdlib.h>#include <stdio.h>#include <pthread.h>#include <string.h>#include <errno.h>#include <time.h>#include <string>#include <vector>#include <iostream>#include <map>#include <fstream>#include "protocol.h"void* client_thread(void* arg);void* console_thread(void* arg);InvertibleRSAFunction privkey;//********************************************************************************string RSA_Encryption(const string & plain){  //Encryption  AutoSeededRandomPool rng;    //Load public key  CryptoPP::RSA::PublicKey pubKey;  CryptoPP::ByteQueue bytes;  FileSource file("pubkey_atm.txt", true, new Base64Decoder);  file.TransferTo(bytes);  bytes.MessageEnd();  pubKey.Load(bytes);      RSAES_OAEP_SHA_Encryptor e(pubKey);    string cipher;  StringSource ss1(plain, true,                   new PK_EncryptorFilter(rng, e,                                          new StringSink(cipher)                                          ) // PK_EncryptorFilter                   ); // StringSource  return cipher;}//********************************************************************************string RSA_Decryption(const string & cipher){  //Decryption  AutoSeededRandomPool rng;  string recovered;    RSAES_OAEP_SHA_Decryptor d(privkey);    StringSource ss2(cipher, true,                   new PK_DecryptorFilter(rng, d,                                          new StringSink(recovered)                                          ) // PK_DecryptorFilter                   ); // StringSource    //assert (plain == recovered);  std::cout << "decrypted plain: " << recovered << std::endl;  return recovered;}//********************************************************************************string signature_sign(const string & msg){    // Setup  string message = msg;  cout << "unsigned message: "<< msg <<endl;  AutoSeededRandomPool rng;    // Sign and Encode  RSASS<PSSR, SHA1>::Signer signer(privkey);    string signature;  // StringSource  StringSource(message, true,               new SignerFilter(rng, signer,                                new StringSink(signature),                                true // putMessage                                ) // SignerFilter               );  return signature;}//********************************************************************************string signature_verify(const string & signature){    RSA::PublicKey publicKey;  string recovered, message;    // Load public key  CryptoPP::ByteQueue bytes;  FileSource file("pubkey_atm.txt", true, new Base64Decoder);  file.TransferTo(bytes);  bytes.MessageEnd();  publicKey.Load(bytes);    // Verify and Recover  RSASS<PSSR, SHA1>::Verifier verifier(publicKey);    StringSource(signature, true,               new SignatureVerificationFilter(                                               verifier,                                               new StringSink(recovered),                                               SignatureVerificationFilter::THROW_EXCEPTION |                                               SignatureVerificationFilter::PUT_MESSAGE                                               ) // SignatureVerificationFilter               ); // StringSource      cout << "Verified Message: " << "'" << recovered << "'" << endl;  return recovered;  }void encryptAndSend(Packet & packet, const string & msg) {    // encryption  string encrypted_msg = RSA_Encryption(msg);  // sign  string signed_msg = signature_sign(encrypted_msg);  cout<<"signed msg length: "<<signed_msg<<endl;    for (int i = 0; i<signed_msg.length(); i++) {    packet.push_back(signed_msg[i]);  }}void receiveAndDecrypt(const Packet & packet, string & msg) {    std::string resp;  resp.append(packet.cbegin(),packet.cend());  // verify  string verified_msg = signature_verify(resp);  // decryption  string decrypted_msg = RSA_Decryption(verified_msg);  cout<<"the message sucessfully decrypted!"<<endl;  msg = decrypted_msg;  cout<<"decrypted_msg: "<<msg<<endl;}//********************************************************************************void SharedKey_Init(){    AutoSeededRandomPool rng;  privkey.Initialize(rng, 1024);    RSAFunction pubkey(privkey);  Base64Encoder pubkeysink(new FileSink("pubkey_bank.txt"));  pubkey.DEREncode(pubkeysink);  pubkeysink.MessageEnd();  }int main(int argc, char* argv[]){  if(argc != 2)  {    printf("Usage: bank listen-port\n");    return -1;  }    unsigned short ourport = atoi(argv[1]);    //crypto setup  SharedKey_Init();    //mutex setup  //pthread_mutex_init(&EVIL_GLOBAL_STATE_MUTEX, NULL);    //socket setup  int lsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  int opt = 1;  setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof opt);  if(!lsock)  {    printf("fail to create socket\n");    return -1;  }    //listening address  sockaddr_in addr_l;  addr_l.sin_family = AF_INET;  addr_l.sin_port = htons(ourport);  unsigned char* ipaddr = reinterpret_cast<unsigned char*>(&addr_l.sin_addr);  ipaddr[0] = 127;  ipaddr[1] = 0;  ipaddr[2] = 0;  ipaddr[3] = 1;  if(0 != bind(lsock, reinterpret_cast<sockaddr*>(&addr_l), sizeof(addr_l)))  {    printf("failed to bind socket\n");    return -1;  }  if(0 != listen(lsock, SOMAXCONN))  {    printf("failed to listen on socket\n");    return -1;  }    pthread_t cthread;  pthread_create(&cthread, NULL, console_thread, NULL);    //loop forever accepting new connections  while(1)  {    sockaddr_in unused;    socklen_t size = sizeof(unused);    int csock = accept(lsock, reinterpret_cast<sockaddr*>(&unused), &size);    if(csock < 0)	//bad client, skip it      continue;        pthread_t thread;    pthread_create(&thread, NULL, client_thread, (void*)csock);  }}void* client_thread(void* arg){  int csock = (int)(size_t)arg;  string decrypted_msg, encrypted_msg;    printf("[bank] client ID #%d connected\n", csock);    //input loop  Packet packet;  packet.resize(PACKET_SIZE);  //std::vector<char> *packet_begin = & packet[0];    while(1)  {    //read the packet from the ATM    if(PACKET_SIZE != recv(csock, & packet[0], PACKET_SIZE, 0))    {      printf("[bank] fail to read packet\n");      break;    }    //decrypt message here    receiveAndDecrypt(packet, decrypted_msg);        std::string msg = "logged in";        Packet response;    //std::vector<char> *response_begin = & response[0];        encryptAndSend(response, msg);        //send the new packet back to the client    if(PACKET_SIZE != send(csock, & response[0], PACKET_SIZE, 0))    {      printf("[bank] fail to send packet\n");      break;    }      }    printf("[bank] client ID #%d disconnected\n", csock);    close(csock);  return NULL;}void* console_thread(void* arg){  char buf[80];  printf("pass to client thread\n\r");}