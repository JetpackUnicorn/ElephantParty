#include <unistd.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <netdb.h>#include <stdlib.h>#include <stdio.h>#include <string.h>#include <errno.h>#include <iostream>#include <fstream>#include "protocol.h"//global variableInvertibleRSAFunction privkey;int sock;bool sock_alive;void receiveAndDecrypt(const Packet & packet, string & msg);void encryptAndSend(Packet & packet, const string & msg);void SharedKey_Init();string signature_verify(const string & signature);string signature_sign(const string & msg);string RSA_Decryption(const string & cipher);string RSA_Encryption(const string & plain);int main(int argc, char* argv[]){  if(argc != 2)  {    printf("Usage: atm proxy-port\n");    return -1;  }    //crypto setup  SharedKey_Init();    //socket setup  unsigned short proxport = atoi(argv[1]);  sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  if(!sock)  {    printf("fail to create socket\n");    return -1;  }  sockaddr_in addr;  addr.sin_family = AF_INET;  addr.sin_port = htons(proxport);  unsigned char* ipaddr = reinterpret_cast<unsigned char*>(&addr.sin_addr);  ipaddr[0] = 127;  ipaddr[1] = 0;  ipaddr[2] = 0;  ipaddr[3] = 1;  if(0 != connect(sock, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)))  {    printf("fail to connect to proxy\n");    return -1;  }  sock_alive = true;    //input loop  char buf[80];    while(1)  {    //printf("atm> ");    //fgets(buf, 79, stdin);    //buf[strlen(buf)-1] = '\0';	//trim off trailing newline    Packet packet;    sock_alive = true;    string resp, command;    //std::vector<char> *packet_begin = & (packet[0]);        cout << "\nATM $";    std::cin >> command;        if(command == "login") {            //encrypt      encryptAndSend(packet, command);            if(PACKET_SIZE != send(sock, & (packet[0]), packet.size(), 0))      {        printf("fail to send packet of command(atm)\n");        sock_alive = false;        return false;      }      else        printf("the command successfully sent\n");            if(PACKET_SIZE != recv(sock, & (packet[0]), PACKET_SIZE, 0))      {        printf("fail to read packet(bank)\n");        sock_alive = false;        return false;      }      else {        receiveAndDecrypt(packet,resp);        cout << "decrypted message: "<<resp<<endl;      }                        if (!sock_alive) {        break;        printf("terminate connection\n");      }    }      }    //cleanup  close(sock);  return 0;}//********************************************************************************//********************************************************************************// ras encryptionstring RSA_Encryption(const string & plain){  // encrypt  AutoSeededRandomPool rng;  // load public key  CryptoPP::RSA::PublicKey pubKey;  CryptoPP::ByteQueue bytes;  FileSource file("pubkey_bank.txt", true, new Base64Decoder);  file.TransferTo(bytes);  bytes.MessageEnd();  pubKey.Load(bytes);    RSAES_OAEP_SHA_Encryptor e(pubKey);    string cipher;  StringSource ss1(plain, true,                   new PK_EncryptorFilter(rng, e,                                          new StringSink(cipher)                                          ) // PK_EncryptorFilter                   ); // StringSource  return cipher;}//********************************************************************************string RSA_Decryption(const string & cipher){  //Decryption  AutoSeededRandomPool rng;  //Load private key  string recovered;    RSAES_OAEP_SHA_Decryptor d(privkey);    StringSource ss2(cipher, true,                   new PK_DecryptorFilter(rng, d,                                          new StringSink(recovered)                                          ) // PK_DecryptorFilter                   ); // StringSource    //assert (plain == recovered);  std::cout << "decrypted plain: " << recovered << std::endl;  return recovered;}//********************************************************************************//sign signaturestring signature_sign(const string & msg){    // Setup  string message = msg;  //cout << "unsigned message: "<< msg <<endl;  RSA::PrivateKey privateKey;  AutoSeededRandomPool rng;    // Sign and Encode  RSASS<PSSR, SHA1>::Signer signer(privkey);    string signature;  // StringSource  StringSource(message, true,               new SignerFilter(rng, signer,                                new StringSink(signature),                                true // putMessage                                )               );  return signature;}//********************************************************************************string signature_verify(const string & signature){    RSA::PublicKey publicKey;  string recovered, message;    // Load public key  CryptoPP::ByteQueue bytes;  FileSource file("pubkey_bank.txt", true, new Base64Decoder);  file.TransferTo(bytes);  bytes.MessageEnd();  publicKey.Load(bytes);    // Verify and Recover  RSASS<PSSR, SHA1>::Verifier verifier(publicKey);  // StringSource  StringSource(signature, true,               new SignatureVerificationFilter(                                               verifier,                                               new StringSink(recovered),                                               SignatureVerificationFilter::THROW_EXCEPTION |                                               SignatureVerificationFilter::PUT_MESSAGE                                               )               );      cout << "Verified Message: " << "'" << recovered << "'" << endl;  return recovered;  }//********************************************************************************void SharedKey_Init(){    AutoSeededRandomPool rng;  privkey.Initialize(rng, 1024);    // public key  RSAFunction pubkey(privkey);  Base64Encoder pubkeysink(new FileSink("pubkey_atm.txt"));  pubkey.DEREncode(pubkeysink);  pubkeysink.MessageEnd();  }//********************************************************************************void encryptAndSend(Packet & packet, const string & msg) {    // encryption  string encrypted_msg = RSA_Encryption(msg);  // sign  string signed_msg = signature_sign(encrypted_msg);  cout<<"signed msg length: "<<signed_msg.length()<<endl;    cout<<"convert signed message to packet:"<<endl;  for (int i = 0; i<signed_msg.length(); i++) {    packet.push_back(signed_msg[i]);    cout<<packet[i]<<",";  }  cout<<"\npacket size: "<<packet.size()<<endl;    std::string tmp;  tmp.append(packet.begin(),packet.end());  assert(tmp == signed_msg);  }void receiveAndDecrypt(const Packet & packet, string & msg) {    std::string resp;  resp.append(packet.cbegin(),packet.cend());  // verify  string verified_msg = signature_verify(resp);   // decryption  string decrypted_msg = RSA_Decryption(verified_msg);    msg = decrypted_msg;}